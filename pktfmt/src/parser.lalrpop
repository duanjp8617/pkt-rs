use std::str::FromStr;
use std::collections::HashMap;

use lalrpop_util::ParseError;

use crate::ast::{BuiltinTypes, Arg, DefaultVal, Field, BitPos, check_header_list};
use crate::file_text::FileText;
use crate::utils::{Spanned, Error};
use crate::token::Token;

grammar<'input>(
    input: &'input FileText
);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        "packet" => Token::Packet,
        "message" => Token::Message,
        "iter_group" => Token::IterGroup,
        "header" => Token::Header,
        "var_header" => Token::VarHeader,
        "with_payload" => Token::WithPayload,
        "header_len" => Token::HeaderLen,
        "payload_len" => Token::PayloadLen,
        "packet_len" => Token::PacketLen,
        "cond" => Token::Cond,
        "messages" => Token::Messages,
        "Field" => Token::Field,
        "bit" => Token::Bit,
        "repr" => Token::Repr,
        "arg" => Token::Arg,
        "default" => Token::Default,
        "gen" => Token::Gen,
        "VarField" => Token::VarField,
        "len" => Token::Len,
        "item_size" => Token::ItemSize,
        "expr" => Token::Expr,
        "min" => Token::Min,
        "max" => Token::Max,
        "ident" => Token::Ident(<&'input str>),
        "builtin type" => Token::BuiltinType(<&'input str>),
        "bool value" => Token::BooleanValue(<&'input str>),
        "==" => Token::Eq,
        "!=" => Token::Neq,
        ">" => Token::Gt,
        ">=" => Token::Ge,
        "<" => Token::Lt,
        "<=" => Token::Le,
        "!" => Token::Not,
        "&&" => Token::And,
        "||" => Token::Or,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mult,
        "/" => Token::Div,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "," => Token::Comma,
        "=" => Token::Assign,
        "num" => Token::Num(<&'input str>),
        "code" => Token::Code(<&'input str>),
        "doc"=> Token::Doc(<&'input str>),
    }
}

// A macro for generating list stored in Vec.
// Taken from lalrpop's parser.
// Note: a lalrpop macro must end with ;.
// An Option<T> can be turned into an iterator Iterator<item = T>.
List<E>: Vec<E> = 
    <v0: (<E> ",")*> <e: E?> => 
        v0.into_iter().chain(e).collect();

pub Num: u64 = {
    "num" => u64::from_str(<>).unwrap()
}

Bool: bool = {
    "bool value" => {
        match <> {
            "true" => true,
            "false" => false,
            _ => panic!()
        }
    }
}

BuiltinTypes: BuiltinTypes = {
    "builtin type" => <>.into()
}

Arg: Arg = {
    BuiltinTypes => Arg::BuiltinTypes(<>),
    "code" => Arg::Code(<>.to_string())
}

DefaultVal: DefaultVal = {
    Num => DefaultVal::Num(<>),
    Bool => DefaultVal::Bool(<>),
    "code" => DefaultVal::Code(<>.to_string())
}

pub Field: Field = {
    <l: @L> "Field" "{"
        "bit" "=" <bit: Num> 
        <repr: ("," "repr" "=" <BuiltinTypes>)?>
        <arg: ("," "arg" "=" <Arg>)?>
        <default: ("," "default" "=" <DefaultVal>)?>
        <gen: ("," "gen" "=" <Bool>)?>
        ","?
    "}" <r: @R> =>? {
        Field::new(bit, repr, arg, default, gen).map_err(|err| {
            let error = Error::Ast {err, span: (l, r)};
            ParseError::User{ error }
        })
    }
}

NamedField: (Spanned<String>, Field) = {
    <l: @L> <field_name: "ident"> <r: @R> "=" <field: Field> => {
        (Spanned{item: field_name.to_string(), span: (l, r)}, field)
    }
}

pub Header: (Vec<(String, Field)>, HashMap<String, (BitPos, BitPos)>) = {
    <l: @L> "header" <r: @R> "=" "["
        <header_list: List<NamedField>>
    "]" =>? {
        check_header_list(header_list, (l, r)).map_err(|(err, span)|{
            let error = Error::Ast{err, span};
            ParseError::User{ error }
        })
    }
}
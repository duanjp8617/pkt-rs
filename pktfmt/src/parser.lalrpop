use std::str::FromStr;
use std::collections::HashMap;

use lalrpop_util::ParseError;

use crate::ast::*;
use crate::file_text::FileText;
use crate::utils::{Spanned, Error};
use crate::token::Token;

grammar<'input>(
    input: &'input FileText
);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        "packet" => Token::Packet,
        "message" => Token::Message,
        "iter_group" => Token::IterGroup,
        "header" => Token::Header,
        "var_header" => Token::VarHeader,
        "with_payload" => Token::WithPayload,
        "header_len" => Token::HeaderLen,
        "payload_len" => Token::PayloadLen,
        "packet_len" => Token::PacketLen,
        "cond" => Token::Cond,
        "messages" => Token::Messages,
        "Field" => Token::Field,
        "bit" => Token::Bit,
        "repr" => Token::Repr,
        "arg" => Token::Arg,
        "default" => Token::Default,
        "gen" => Token::Gen,
        "expr" => Token::Expr,
        "min" => Token::Min,
        "max" => Token::Max,
        "option_name" => Token::OptionName,
        "ident" => Token::Ident(<&'input str>),
        "builtin type" => Token::BuiltinType(<&'input str>),
        "bool value" => Token::BooleanValue(<&'input str>),
        "==" => Token::Eq,
        "!=" => Token::Neq,
        ">" => Token::Gt,
        ">=" => Token::Ge,
        "<" => Token::Lt,
        "<=" => Token::Le,
        "!" => Token::Not,
        "&&" => Token::And,
        "||" => Token::Or,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mult,
        "/" => Token::Div,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "," => Token::Comma,
        "=" => Token::Assign,
        "num" => Token::Num(<&'input str>),
        "code" => Token::Code(<&'input str>),
        "doc"=> Token::Doc(<&'input str>),
    }
}

// A macro for generating list stored in Vec.
// Taken from lalrpop's parser.
// Note: a lalrpop macro must end with ;.
// An Option<T> can be turned into an iterator Iterator<item = T>.
List<E>: Vec<E> = 
    <v0: (<E> ",")*> <e: E?> => 
        v0.into_iter().chain(e).collect();

pub Num: u64 = {
    "num" => u64::from_str(<>).unwrap()
}

Bool: bool = {
    "bool value" => {
        match <> {
            "true" => true,
            "false" => false,
            _ => panic!()
        }
    }
}

BuiltinTypes: BuiltinTypes = {
    "builtin type" => <>.into()
}

Arg: Arg = {
    BuiltinTypes => Arg::BuiltinTypes(<>),
    "code" => Arg::Code(<>.to_string())
}

DefaultVal: DefaultVal = {
    Num => DefaultVal::Num(<>),
    Bool => DefaultVal::Bool(<>),
    "code" => DefaultVal::Code(<>.to_string())
}

pub Field: Field = {
    <l: @L> "Field" "{"
        "bit" "=" <bit: Num> 
        <repr: ("," "repr" "=" <BuiltinTypes>)?>
        <arg: ("," "arg" "=" <Arg>)?>
        <default: ("," "default" "=" <DefaultVal>)?>
        <gen: ("," "gen" "=" <Bool>)?>
        ","?
    "}" <r: @R> =>? {
        Field::new(bit, repr, arg, default, gen).map_err(|err| {
            let error = Error::Ast {err, span: (l, r)};
            ParseError::User{ error }
        })
    }
}

NamedField: (Spanned<String>, Field) = {
    <l: @L> <field_name: "ident"> <r: @R> "=" <field: Field> => {
        (Spanned{item: field_name.to_string(), span: (l, r)}, field)
    }
}

pub Header: (Vec<(String, Field)>, HashMap<String, (BitPos, BitPos)>) = {
    <l: @L> "header" "=" "["
        <header_list: List<NamedField>>
    "]" <r: @R> =>? {
        check_header_list(header_list, (l, r)).map_err(|(err, span)|{
            let error = Error::Ast{err, span};
            ParseError::User{ error }
        })
    }
}

AddExpr: Box<AlgExpr> = {
    <lexpr: AddExpr> "+" <rexpr: MultExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Add, rexpr)),
    <lexpr: AddExpr> "-" <rexpr: MultExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Sub, rexpr)),
    MultExpr => <>
}

MultExpr: Box<AlgExpr> = {
    <lexpr: MultExpr> "*" <rexpr: AlgBaseExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Mul, rexpr)),
    <lexpr: MultExpr> "/" <rexpr: AlgBaseExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Div, rexpr)),
    AlgBaseExpr => <>
}

AlgBaseExpr: Box<AlgExpr> = {
    "num" => Box::new(AlgExpr::Num(u64::from_str(<>).unwrap())),
    "ident" => Box::new(AlgExpr::Ident(String::from_str(<>).unwrap())),
    "(" <AddExpr> ")" => <>
}

AlgExpr: Box<AlgExpr> = {
    AddExpr => <>
}

LengthBase: (Box<AlgExpr>, u64, Option<u64>) = {
    "expr" "=" <expr: AlgExpr> "," 
    "min" "=" <min: "num"> 
    <max: ("," "max" "=" <"num">)?> => 
        (expr, u64::from_str(min).unwrap(), max.map(|s| u64::from_str(s).unwrap()))
}

HeaderLenOption: (LengthInfo, String) = {
    <length_base: LengthBase> 
    <option_name: (","  "option_name" "=" <"ident">)?>
    ","? => {
        let (expr, min, max) = length_base;
        match option_name {
            Some(str) => (LengthInfo {expr, min, max}, String::from_str(str).unwrap()),
            _ => (LengthInfo {expr, min, max}, String::from_str("option").unwrap())
        }
    }
}

// pub Packet: Packet = {
//     "packet" <name: "ident"> "{"
//         "header" "=" "["
//         "]"
//
//    "}"
// }
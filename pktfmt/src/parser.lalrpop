use std::str::FromStr;
use std::collections::HashMap;

use lalrpop_util::ParseError;

use crate::ast_new::{
    Field, BuiltinTypes, Arg, DefaultVal, BitPos, check_header_list, AlgOp, AlgExpr, UsableAlgExpr, parse_to_byte_val, LengthField
};
use crate::file_text::FileText;
use crate::utils::{Spanned, Error};
use crate::token::Token;

grammar<'input>;

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        // top-level 
        "packet" => Token::Packet,
        
        // header
        "header" => Token::Header,
        "Field" => Token::Field,
        "bit" => Token::Bit,
        "repr" => Token::Repr,
        "arg" => Token::Arg,
        "default" => Token::Default,
        "gen" => Token::Gen,

        // length
        "length" => Token::Length,
        "header_len" => Token::HeaderLen,
        "payload_len" => Token::PayloadLen,
        "packet_len" => Token::PacketLen,
        // Algorithmic
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mult,
        "/" => Token::Div,

        // condition
        "cond" => Token::Cond,
        // comparison
        "==" => Token::Eq,
        "!=" => Token::Neq,
        ">" => Token::Gt,
        ">=" => Token::Ge,
        "<" => Token::Lt,
        "<=" => Token::Le,
        // logical
        "!" => Token::Not,
        "&&" => Token::And,
        "||" => Token::Or,

        // identifiers
        "ident" => Token::Ident(<&'input str>),

        // builtin types
        "builtin type" => Token::BuiltinType(<&'input str>),

        // boolean value, true, false
        "bool value" => Token::BooleanValue(<&'input str>),
        
        // brackets
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,

        // comma
        "," => Token::Comma,

        // assign
        "=" => Token::Assign,

        // numbers
        "num" => Token::Num(<&'input str>),

        // rust code
        "code" => Token::Code(<&'input str>),

        // doc
        "doc"=> Token::Doc(<&'input str>),
    }
}

// A macro for generating list stored in Vec.
// Taken from lalrpop's parser.
// Note: a lalrpop macro must end with ;.
// An Option<T> can be turned into an iterator Iterator<item = T>.
List<E>: Vec<E> = 
    <v0: (<E> ",")*> <e: E?> => {
        v0.into_iter().chain(e).collect()
};

pub Num: u64 = {
    "num" => u64::from_str(<>).unwrap()
}

Bool: bool = {
    "bool value" => {
        match <> {
            "true" => true,
            "false" => false,
            _ => panic!()
        }
    }
}

BuiltinTypes: BuiltinTypes = {
    "builtin type" => <>.into()
}

Arg: Arg = {
    BuiltinTypes => Arg::BuiltinTypes(<>),
    <s: "code"> => Arg::Code((&s[2..(s.len()-2)]).to_string())
}

Byte: u8  = {
    <l: @L> <num: "num"> <r: @R> =>? {
        parse_to_byte_val(num).map_err(|err| {
            let error = Error::AstNew {err, span: (l, r)};
            ParseError::User{ error }
        })
    }
}

ByteArray: Vec<u8> = {
    "[" <List<Byte>> "]" => <>
}

DefaultVal: DefaultVal = {
     Num => DefaultVal::Num(<>),
     Bool => DefaultVal::Bool(<>),
     ByteArray => DefaultVal::Bytes(<>)
}

pub Field: Field = {
    <l: @L> "Field" "{"
        "bit" "=" <bit: Num> 
        <repr: ("," "repr" "=" <BuiltinTypes>)?>
        <arg: ("," "arg" "=" <Arg>)?>
        <default: ("," "default" "=" <DefaultVal>)?>
        <gen: ("," "gen" "=" <Bool>)?>
        ","?
    "}" <r: @R> =>? {
        Field::new(bit, repr, arg, default, gen).map_err(|err| {
            let error = Error::AstNew {err, span: (l, r)};
            ParseError::User{ error }
        })
    }
}

NamedField: (Spanned<String>, Field) = {
    <l: @L> <field_name: "ident"> <r: @R> "=" <field: Field> => {
        (Spanned{item: field_name.to_string(), span: (l, r)}, field)
    }
}

pub Header: (Vec<(String, Field)>, HashMap<String, (BitPos, usize)>) = {
    <l: @L> "header" "=" "["
        <header_list: List<NamedField>>
    "]" <r: @R> =>? {
        check_header_list(header_list, (l, r)).map_err(|(err, span)|{
            let error = Error::AstNew{err, span};
            ParseError::User{ error }
        })
    }
}

AddExpr: Box<AlgExpr> = {
    <lexpr: AddExpr> "+" <rexpr: MultExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Add, rexpr)),
    <lexpr: AddExpr> "-" <rexpr: MultExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Sub, rexpr)),
    MultExpr => <>
}

MultExpr: Box<AlgExpr> = {
    <lexpr: MultExpr> "*" <rexpr: AlgBaseExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Mul, rexpr)),
    <lexpr: MultExpr> "/" <rexpr: AlgBaseExpr> => 
        Box::new(AlgExpr::Binary(lexpr, AlgOp::Div, rexpr)),
    AlgBaseExpr => <>
}

AlgBaseExpr: Box<AlgExpr> = {
    "num" => Box::new(AlgExpr::Num(u64::from_str(<>).unwrap())),
    "ident" => Box::new(AlgExpr::Ident(String::from_str(<>).unwrap())),
    "(" <AddExpr> ")" => <>
}

AlgExpr: UsableAlgExpr = {
    <l: @L> <expr: AddExpr> <r: @R> =>? {
        expr.try_take_usable_alg_expr().map_err(|err| {
            let error = Error::AstNew {err, span: (l, r)};
            ParseError::User{ error }
        })
    }
}

HeaderLenAssign: Option<UsableAlgExpr> = {
    "header_len" "=" <expr: (AlgExpr)?> => expr
}

PayloadLenAssign: Option<UsableAlgExpr> = {
    "payload_len" "=" <expr: (AlgExpr)?> => expr
}

PacketLenAssign: Option<UsableAlgExpr> = {
    "packet_len" "=" <expr: (AlgExpr)?> => expr
}

// (opt, 0) => header_len
// (opt, 1) => payload_len
// (opt, 2) => packet_len
EitherHeaderOrPayloadOrPacket: (Option<UsableAlgExpr>, usize) = {
    HeaderLenAssign => (<>, 0),
    PayloadLenAssign => (<>, 1),
    PacketLenAssign => (<>, 2)
}

EitherPayloadOrPacket: (Option<UsableAlgExpr>, usize) = {
    PayloadLenAssign => (<>, 1),
    PacketLenAssign => (<>, 2)
}

LengthFieldListSubRule: Vec<LengthField> = {
    // Length parse 1: only one of the length field is defined
    <opt: EitherHeaderOrPayloadOrPacket> ","? => {
        let mut v = vec![LengthField::None, LengthField::None, LengthField::None];
        v[opt.1] = LengthField::from_option(opt.0);
        v
    },
    // Length parse 2: header length field is defined. one of payload/packet length is defined
    <header_len_opt: HeaderLenAssign> "," <opt_with_index: EitherPayloadOrPacket> ","? => {
        let mut v = vec![LengthField::None, LengthField::None, LengthField::None];
        v[0] =  LengthField::from_option(header_len_opt);
        v[opt_with_index.1] = LengthField::from_option(opt_with_index.0);
        v
    },
    // Length parse 3: header is optional, both payload and packet length are defined
    <header_len_opt_opt: (<HeaderLenAssign> ",")?> 
    <payload_len_opt: PayloadLenAssign> "," <packet_len_opt: PacketLenAssign> ","? => {
        let mut v = vec![LengthField::None, LengthField::None, LengthField::None];
        if let Some(header_len_opt) = header_len_opt_opt {
            v[0] =  LengthField::from_option(header_len_opt);
        }
        v[1] =  LengthField::from_option(payload_len_opt);
        v[2] =  LengthField::from_option(packet_len_opt);
        v
    }
}

LengthFieldList: (Vec<LengthField>, (usize, usize)) = {
    <l: @L> "header" "=" "[" <list: LengthFieldListSubRule>  "]" <r: @R> => (list, (l, r))
}

